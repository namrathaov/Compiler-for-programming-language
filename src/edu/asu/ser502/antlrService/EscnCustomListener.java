package edu.asu.ser502.antlrService;

/**
 * This class extends EscnBaseListener generated by Antlr to write have 
 * ESCN's intermediate file code. Required methods are being overridden
 * in this class.
 *
 * @author Rhythm Sharma
 * @version 1.0
 */
import java.util.ArrayList;

import edu.asu.ser502.utils.*;
import edu.asu.ser502.antlrService.EscnParser.*;

public class EscnCustomListener extends EscnBaseListener {
	private static ArrayList<String> icfContent = new ArrayList<>();
	private static int tempIndex = 0;
	/**
     * Returns the icfContent
     */
	public static ArrayList<String> getIcfContent() {
		return icfContent;
	}

	/**
     * Updates the identifier table and icfContent for the declared identifier
     *
     * @param ctx DeclarationStmt Context
     */
	@Override
	public void enterDeclarationStmt(DeclarationStmtContext ctx) {
		
		if (ctx.getChildCount() != 3) {
			try {
				throw new Exception("Declaration is not done properly.");
			} catch (Exception e) {
				e.printStackTrace();
			}
			return;
		}
		
		StringBuilder declarationStmt = new StringBuilder();
		String identifier = ctx.getChild(1).getText();
		String dataType = ctx.getChild(0).getText();
		
		if (EscnUtils.getEscnUtilsInstance().updateIdentifierTable(identifier, dataType)) {
			
			switch (dataType) {
				case "int":
					declarationStmt.append("NUM");
					break;
				case "boolean":
					declarationStmt.append("BOOL");
					break;
				default:
					try {
						throw new Exception("DATATYPE NOT SUPPORTED");
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
			declarationStmt.append(" " + identifier);
			icfContent.add(declarationStmt.toString());
		} else {
			EscnErrorListener.INSTANCE.escnException("Identifier declared more than once");
		}
	}
	
	/**
	 * Updating the icfContent with OUT statement
	 *
	 * @param ctx print statement context
	 */	
	@Override
	public void exitPrintStmt(PrintStmtContext ctx) {
		
		String expr =  ctx.getChild(2).getText();
		String regex = "\\d+";
		
		if(EscnUtils.getEscnUtilsInstance().getArithmeticOperator(expr) == null || expr.matches(regex) || expr.equals("true") || expr.equals("false")) {
			icfContent.add("OUT " + expr);
		} else {
			
			/*
			 * value could be arithmetic expression only in else case 
			 * expression has been evaluated and stored in temp location.
			 * */
			if (EscnUtils.symbolTable.containsValue(expr)) {
				icfContent.add("OUT" + " " + EscnUtils.getEscnUtilsInstance().getSymbolTableKey(expr));
            } else {
            	icfContent.add("OUT" + " " + expr);
            }
		}
	}
	
	/**
     * Evaluates the conditions of if logical statement
     *
     * @param ctx LogicalStmtContext Context
     */
	public void ifLogicalStatement(LogicalStmtContext ctx) {
		
		if((ctx.getChild(1).getText().equals("==") || ctx.getChild(1).getText().equals("!=")) && (ctx.getChild(0).getText().equals("true") || ctx.getChild(2).getText().equals("true") 
				|| ctx.getChild(0).getText().equals("false") || ctx.getChild(2).getText().equals("false"))) {
			if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(0).getText()) == null) {
				
				// First operand is boolean value and second operand is a logical statement
				ifLogicalStatement((LogicalStmtContext) ctx.getChild(2));
				String tempStr = "ifTemp" + tempIndex;
		        icfContent.add("BOOL " + tempStr);
		        icfContent.add("SET " + tempStr + "," + ctx.getChild(0).getText());
		        EscnUtils.symbolTable.put(tempStr, ctx.getChild(0).getText());
		        StringBuilder logicalNotation = new StringBuilder();
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(1).getText())).append(" ");
		        logicalNotation.append(tempStr + ",");
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(ctx.getChild(2).getText()));
		        icfContent.add(logicalNotation.toString());
		        EscnUtils.symbolTable.put(tempStr, ctx.getText());
		        tempIndex++;
			} else if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(2).getText()) == null) {
				
				// Second operand is boolean value and first operand is a logical statement
				ifLogicalStatement((LogicalStmtContext) ctx.getChild(0));
				String tempStr = "ifTemp" + tempIndex;
		        icfContent.add("BOOL " + tempStr);
		        icfContent.add("SET " + tempStr + "," + ctx.getChild(2).getText());
		        StringBuilder logicalNotation = new StringBuilder();
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(1).getText())).append(" ");
		        logicalNotation.append(tempStr + ",");
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(ctx.getChild(0).getText()));
		        icfContent.add(logicalNotation.toString());
		        EscnUtils.symbolTable.put(tempStr, ctx.getText());
		        tempIndex++;
			} else {
				
				// The expression is not valid as per our language
				EscnErrorListener.INSTANCE.escnException("Logical statement is not valid");
				return;
			}
			
		} else if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(0).getText()) == null
				&& EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(2).getText()) == null) {
			
			// Operands are identifiers
			String evaluatingExpr = ctx.getText();
			String operatorSymbol = ctx.getChild(1).getText();
			String operand1 = ctx.getChild(0).getText();
			String operand2 = ctx.getChild(2).getText();
			ifChildLogicalStmt(evaluatingExpr, operatorSymbol, operand1, operand2);
		} else {
			EscnErrorListener.INSTANCE.escnException("Logical statement is not valid");
			return;
		}
	}
	/**
     * Evaluates the three child logical Statement
     *
     * @param evaluatingExpr Expression needs to be evaluated for prefix notation
     * @param operator Operator in the logical statement
     * @param First Operand
     * @param Second Operand
     */
    private void ifChildLogicalStmt(String evaluatingExpr, String operator, String operand1, String operand2) {
		
		String operatorNotation = EscnUtils.getEscnUtilsInstance().getLogicalOperator(operator);
		if(operatorNotation == null) {
			EscnErrorListener.INSTANCE.escnException("Operator is not supported.");
			return;
		}
		
		StringBuilder logicalNotation = new StringBuilder();
        String tempStr = "ifTemp" + tempIndex;
        tempIndex++;
        icfContent.add("NUM " + tempStr);
        icfContent.add("SET " + tempStr + "," + operand1);
        EscnUtils.symbolTable.put(tempStr, operand1);
        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(operator)).append(" ");
        logicalNotation.append(tempStr + ",");
        logicalNotation.append(operand2);
        icfContent.add(logicalNotation.toString());
        EscnUtils.symbolTable.put(tempStr, evaluatingExpr);
		 
	}
	/**
	 * Updating the icfContent with if condition
	 *
	 * @param ctx if statement context
	 */
	@Override public void enterIfSection(EscnParser.IfSectionContext ctx) {
        StringBuilder logicalNotation = new StringBuilder();
        ifLogicalStatement((LogicalStmtContext) ctx.getChild(1));
        logicalNotation.setLength(0);
        logicalNotation.append("IF").append(" ").append(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(ctx.getChild(1).getText()));
        icfContent.add(logicalNotation.toString());
        tempIndex++;
	}

	/**
	 * Appends the icfContent with end-if at the end of if-else construct 
	 *
	 * @param ctx if Statement context
	 */
	@Override public void exitIfStmt(EscnParser.IfStmtContext ctx) { 
		for(int i =0;i<ctx.getChildCount();i++) {
			if(ctx.getChild(i).getText().equals("endif")) {
				icfContent.add(ctx.getChild(i).getText().toUpperCase());
			}
		}

	}

	
	@Override public void enterElseSection(EscnParser.ElseSectionContext ctx) { 
		icfContent.add("ELSE");
	}

	/**
     * Assign the identifier the value
     *
     * @param ctx AssignStmt Context
     */
	@Override
	public void exitAssignStmt(AssignStmtContext ctx) {

		String variable = ctx.getChild(0).getText();
		String value = ctx.getChild(2).getText();
		String regex = "\\d+";
		
		if(EscnUtils.getEscnUtilsInstance().getArithmeticOperator(value) == null 
				|| value.matches(regex)
				|| value.equals("true") 
				|| value.equals("false")) {
			if(EscnUtils.getEscnUtilsInstance().getIdentifierType(variable).equals("boolean") && 
					(value.matches(regex) || EscnUtils.getEscnUtilsInstance().getIdentifierType(value).equals("int"))) {
				EscnErrorListener.INSTANCE
				.escnException("Arithmetic operation not possible between int and boolean");
			}
			icfContent.add("SET " + variable + "," + value);
		} else {
			
			// value could be arithmetic expression only
			// Assignment can be done on same datatypes only
			if(EscnUtils.getEscnUtilsInstance().getIdentifierType(variable).equals("int")) {
				icfContent.add("SET " +variable + "," + EscnUtils.getEscnUtilsInstance().getSymbolTableKey(value));
			} else {
				EscnErrorListener.INSTANCE
				.escnException("Arithmetic operation not possible between int and boolean");
			}
		}
	}
	
	/**
     * Evaluates the expression and store the notation in expression table
     *
     * @param ctx Expression Context
     */
	@Override
	public void exitExpr(ExprContext ctx) {
		
		if (ctx.getChildCount() % 2 == 0) {
			EscnErrorListener.INSTANCE.escnException("invalid number of operands and operator");
			return;
		}
		
		if(ctx.getChildCount() == 3) {
			
			String evaluatingExpr = ctx.getText();
			String operatorSymbol = ctx.getChild(1).getText();
			String operand1 = ctx.getChild(0).getText();
			String operand2 = ctx.getChild(2).getText();
			threeChildExpression(evaluatingExpr, operatorSymbol, operand1, operand2);
		}
	}
	
	/**
     * Evaluates the term (expression with higher precedence) and store the notation in expression table
     *
     * @param ctx Term Context
     */	
	@Override
	public void exitTerm(TermContext ctx) {

		if (ctx.getChildCount() % 2 == 0) {
			EscnErrorListener.INSTANCE.escnException("invalid number of operands and operator");
			return;
		}
		
		if(ctx.getChildCount() == 3) {
			
			String evaluatingExpr = ctx.getText();
			String operatorSymbol = ctx.getChild(1).getText();
			String operand1 = ctx.getChild(0).getText();
			String operand2 = ctx.getChild(2).getText();
			threeChildExpression(evaluatingExpr, operatorSymbol, operand1, operand2);
		}
	}

	/**
     * Evaluates the expression and store the notation in expression table
     *
     * @param ctx Expression Context
     */
	private void threeChildExpression(String evaluatingExpr, String operator, String operand1, String operand2) {
		
		String operatorNotation = EscnUtils.getEscnUtilsInstance().getArithmeticOperator(operator);
		String tempStr = operand1;
		if(operatorNotation == null) {
			EscnErrorListener.INSTANCE.escnException("Operator is not supported.");
			return;
		}
		
		if(!EscnUtils.symbolTable.containsKey(operand1)) {
			tempStr = "temp"+tempIndex;
			icfContent.add("NUM " + tempStr);
			EscnUtils.getEscnUtilsInstance().updateIdentifierTable(tempStr, "int");
			
			// If the prefix notation for operand is known, then fetch from symbol table
			if(EscnUtils.symbolTable.containsValue(operand1)) {
				EscnUtils.symbolTable.put(tempStr, EscnUtils.getEscnUtilsInstance().getSymbolTableKey(operand1));
				icfContent.add("SET " + tempStr + "," + EscnUtils.getEscnUtilsInstance().getSymbolTableKey(operand1));
			} else {
				EscnUtils.symbolTable.put(tempStr, operand1);
				icfContent.add("SET " + tempStr + "," + operand1);
			}
			tempIndex++;
		}
		
		if(operand2.matches("\\d+") || EscnUtils.getEscnUtilsInstance().getIdentifierType(tempStr).equals(EscnUtils.getEscnUtilsInstance().getIdentifierType(operand2)) ||
				EscnUtils.getEscnUtilsInstance().getIdentifierType(tempStr)
				.equals(EscnUtils.getEscnUtilsInstance().getIdentifierType(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(operand2)))) {
			
			if(EscnUtils.getEscnUtilsInstance().getArithmeticOperator(operand2) != null)
				icfContent.add(operatorNotation + " " + tempStr + "," + EscnUtils.getEscnUtilsInstance().getSymbolTableKey(operand2));
			else
				icfContent.add(operatorNotation + " " + tempStr + "," + operand2);
			
			EscnUtils.symbolTable.put(tempStr, evaluatingExpr);
		} else {
			EscnErrorListener.INSTANCE.escnException("Arithmetic operation not possible between int and boolean");
			return;
		}
	}
	
	/**
     * Evaluates the while logical expression at the starting
     *
     * @param ctx WhileStmtContext Context
     */
	@Override
	public void enterWhileStmt(WhileStmtContext ctx) {
	        
			StringBuilder logicalNotation = new StringBuilder();
	        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(1).getChild(1).getText())).append(" ");
	        logicalNotation.append(ctx.getChild(1).getChild(0).getText() + ",");
	        logicalNotation.append(ctx.getChild(1).getChild(2).getText());
	        String tempStr = logicalNotation.toString();
	        icfContent.add("ALA " + tempStr);
	        EscnUtils.symbolTable.put(tempStr, ctx.getChild(1).getText());
	    }
		
	   
	/**
     * Evaluates the three child logical Statement
     *
     * @param evaluatingExpr Expression needs to be evaluated for prefix notation
     * @param operator Operator in the logical statement
     * @param First Operand
     * @param Second Operand
     */
    private void threeChildLogicalStmt(String evaluatingExpr, String operator, String operand1, String operand2) {
		
		String operatorNotation = EscnUtils.getEscnUtilsInstance().getLogicalOperator(operator);
		if(operatorNotation == null) {
			EscnErrorListener.INSTANCE.escnException("Operator is not supported.");
			return;
		}
		
		StringBuilder logicalNotation = new StringBuilder();
        String tempStr = "whileTemp" + tempIndex;
        tempIndex++;
        icfContent.add("BOOL " + tempStr);
        icfContent.add("SET " + tempStr + "," + operand1);
        EscnUtils.symbolTable.put(tempStr, operand1);
        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(operator)).append(" ");
        logicalNotation.append(tempStr + ",");
        logicalNotation.append(operand2);
        icfContent.add(logicalNotation.toString());
        EscnUtils.symbolTable.put(tempStr, evaluatingExpr);
		 
	}

    /**
     * Evaluates the while logical expression before running loop again
     *
     * @param ctx WhileStmtContext Context
     */
    @Override
    public void exitWhileStmt(WhileStmtContext ctx) {
        icfContent.add("GOBACK");
    }
	
   
	
	private void enterLogicalStatement(LogicalStmtContext ctx, String tempStr) {

		
		if((ctx.getChild(1).getText().equals("==") || ctx.getChild(1).getText().equals("!=")) && (ctx.getChild(0).getText().equals("true") || ctx.getChild(2).getText().equals("true") 
				|| ctx.getChild(0).getText().equals("false") || ctx.getChild(2).getText().equals("false"))) {
			if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(0).getText()) == null) {
				
				// First operand is boolean value and second operand is a logical statement
				enterLogicalStatement((LogicalStmtContext) ctx.getChild(2));
		        icfContent.add("SET " + tempStr + "," + ctx.getChild(0).getText());
		        EscnUtils.symbolTable.put(tempStr, ctx.getChild(0).getText());
		        StringBuilder logicalNotation = new StringBuilder();
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(1).getText())).append(" ");
		        logicalNotation.append(tempStr + ",");
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(ctx.getChild(2).getText()));
		        icfContent.add(logicalNotation.toString());
		        EscnUtils.symbolTable.put(tempStr, ctx.getText());
			} else if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(2).getText()) == null) {
				
				// Second operand is boolean value and first operand is a logical statement
				enterLogicalStatement((LogicalStmtContext) ctx.getChild(0));
		        icfContent.add("SET " + tempStr + "," + ctx.getChild(2).getText());
		        StringBuilder logicalNotation = new StringBuilder();
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(1).getText())).append(" ");
		        logicalNotation.append(tempStr + ",");
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(ctx.getChild(0).getText()));
		        icfContent.add(logicalNotation.toString());
		        EscnUtils.symbolTable.put(tempStr, ctx.getText());
			} else {
				
				// The expression is not valid as per our language
				EscnErrorListener.INSTANCE.escnException("Logical statement is not valid");
				return;
			}
			
		} else if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(0).getText()) == null
				&& EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(2).getText()) == null) {
			
			// Operands are identifiers
			String evaluatingExpr = ctx.getText();
			String operatorSymbol = ctx.getChild(1).getText();
			String operand1 = ctx.getChild(0).getText();
			String operand2 = ctx.getChild(2).getText();
			threeChildLogicalStmt(evaluatingExpr, operatorSymbol, operand1, operand2, tempStr);
		} else {
			EscnErrorListener.INSTANCE.escnException("Logical statement is not valid");
			return;
		}
	
	}

	private void threeChildLogicalStmt(String evaluatingExpr, String operator, String operand1, String operand2,
			String tempStr) {
		
		String operatorNotation = EscnUtils.getEscnUtilsInstance().getLogicalOperator(operator);
		if(operatorNotation == null) {
			EscnErrorListener.INSTANCE.escnException("Operator is not supported.");
			return;
		}
		
		StringBuilder logicalNotation = new StringBuilder();
        icfContent.add("SET " + tempStr + "," + operand1);
        EscnUtils.symbolTable.put(tempStr, operand1);
        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(operator)).append(" ");
        logicalNotation.append(tempStr + ",");
        logicalNotation.append(operand2);
        icfContent.add(logicalNotation.toString());
        EscnUtils.symbolTable.put(tempStr, evaluatingExpr);
		 
	}

	/**
     * Evaluates the logical statement
     *
     * @param ctx LogicalStmtContext Context
     */
	public void enterLogicalStatement(LogicalStmtContext ctx) {
		
		if((ctx.getChild(1).getText().equals("==") || ctx.getChild(1).getText().equals("!=")) && (ctx.getChild(0).getText().equals("true") || ctx.getChild(2).getText().equals("true") 
				|| ctx.getChild(0).getText().equals("false") || ctx.getChild(2).getText().equals("false"))) {
			if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(0).getText()) == null) {
				
				// First operand is boolean value and second operand is a logical statement
				enterLogicalStatement((LogicalStmtContext) ctx.getChild(2));
				String tempStr = "whileTemp" + tempIndex;
		        icfContent.add("BOOL " + tempStr);
		        icfContent.add("SET " + tempStr + "," + ctx.getChild(0).getText());
		        EscnUtils.symbolTable.put(tempStr, ctx.getChild(0).getText());
		        StringBuilder logicalNotation = new StringBuilder();
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(1).getText())).append(" ");
		        logicalNotation.append(tempStr + ",");
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(ctx.getChild(2).getText()));
		        icfContent.add(logicalNotation.toString());
		        EscnUtils.symbolTable.put(tempStr, ctx.getText());
		        tempIndex++;
			} else if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(2).getText()) == null) {
				
				// Second operand is boolean value and first operand is a logical statement
				enterLogicalStatement((LogicalStmtContext) ctx.getChild(0));
				String tempStr = "whileTemp" + tempIndex;
		        icfContent.add("BOOL " + tempStr);
		        icfContent.add("SET " + tempStr + "," + ctx.getChild(2).getText());
		        StringBuilder logicalNotation = new StringBuilder();
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(1).getText())).append(" ");
		        logicalNotation.append(tempStr + ",");
		        logicalNotation.append(EscnUtils.getEscnUtilsInstance().getSymbolTableKey(ctx.getChild(0).getText()));
		        icfContent.add(logicalNotation.toString());
		        EscnUtils.symbolTable.put(tempStr, ctx.getText());
		        tempIndex++;
			} else {
				
				// The expression is not valid as per our language
				EscnErrorListener.INSTANCE.escnException("Logical statement is not valid");
				return;
			}
			
		} else if(EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(0).getText()) == null
				&& EscnUtils.getEscnUtilsInstance().getLogicalOperator(ctx.getChild(2).getText()) == null) {
			
			// Operands are identifiers
			String evaluatingExpr = ctx.getText();
			String operatorSymbol = ctx.getChild(1).getText();
			String operand1 = ctx.getChild(0).getText();
			String operand2 = ctx.getChild(2).getText();
			threeChildLogicalStmt(evaluatingExpr, operatorSymbol, operand1, operand2);
		} else {
			EscnErrorListener.INSTANCE.escnException("Logical statement is not valid");
			return;
		}
	}
}
